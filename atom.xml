<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of TheChef</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-05T12:32:30.427Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TheChef</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[2024-04-11] LLM #1:Agent简介</title>
    <link href="http://example.com/2024/04/11/2024-04-11-1-LLM-Agent/"/>
    <id>http://example.com/2024/04/11/2024-04-11-1-LLM-Agent/</id>
    <published>2024-04-10T16:23:04.000Z</published>
    <updated>2024-05-05T12:32:30.427Z</updated>
    
    <content type="html"><![CDATA[<img src="/2024/04/11/2024-04-11-1-LLM-Agent/agent-overview.png" class="" title="Agent Overview"><h1 id="Agent介绍"><a href="#Agent介绍" class="headerlink" title="Agent介绍"></a>Agent介绍</h1><h2 id="什么是-AI-代理"><a href="#什么是-AI-代理" class="headerlink" title="什么是 AI 代理"></a>什么是 AI 代理</h2><p>AI代理（AI agent）是指使用 AI 技术设计和编程的一种计算机程序，其可以独立地进行某些任务并对环境做出反应。AI代理可以被视为一个智能体，它能够感知其环境，通过自己的决策和行动来改变环境，并通过学习和适应来提高其性能。这种智能体同时使用短期记忆（上下文学习）和长期记忆（从外部向量存储中检索信息），有能力通过逐步“思考”来计划、将目标分解为更小的任务 ，并反思自己的表现。AI代理通常包含多种技术，如机器学习、自然语言处理、计算机视觉、规划和推理等，这些技术使代理能够自主地处理信息并作出决策。</p><span id="more"></span><h2 id="什么是-LLM-支持的自主代理"><a href="#什么是-LLM-支持的自主代理" class="headerlink" title="什么是 LLM 支持的自主代理"></a>什么是 LLM 支持的自主代理</h2><p>OpenAI AI应用研究主管 Lilian Weng 最近发布了一篇关于 AI 代理的万字长文：《大语言模型（LLM）支持的自主代理》，深度解读了什么是由 LLM 训练构建的 AI 代理应用。LLM 支持的 AI 代理现在已经出现了很多优秀的应用，例如 AutoGPT、GPT-Engineer、BabyAGI 和 SuperAGI 等。在LLM 支持的自主代理系统中，LLM 充当代理的大脑，并由几个关键组件进行补充：规划（Planning）、内存（Memory）、工具使用（Tool Use)。</p><h2 id="任务规划"><a href="#任务规划" class="headerlink" title="任务规划"></a>任务规划</h2><ul><li><p>任务拆分：<br>复杂任务不是一次性就能解决的，需要拆分成多个并行或串行的子任务来进行求解，任务规划的目标是找到一条最优的、能够解决问题的路线</p></li><li><p>自我反省：<br>自我反思是一个重要的方面，它允许自主代理通过完善过去的行动决策和纠正以前的错误来迭代改进。它在不可避免地会出现试错的现实任务中发挥着至关重要的作用。ReAct (Yao et al. 2023) 发现让Agents执行下一步action的时候，加上LLM自己的思考过程，并将思考过程、执行的工具及参数、执行的结果放到prompt中，就能使得模型对当前和先前的任务完成度有更好的反思能力，从而提升模型的问题解决能力。</p></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thought: ... </span><br><span class="line">Action: ... </span><br><span class="line">Observation: ... </span><br><span class="line">...(重复以上过程）</span><br></pre></td></tr></table></figure><ul><li><p>思想链：<br>已成为增强复杂任务模型性能的标准提示技术。该模型被指示“一步一步思考”，以利用更多的测试时间计算将困难任务分解为更小、更简单的步骤。 CoT 将大型任务转化为多个可管理的任务，并阐明模型思维过程的解释。</p></li><li><p>思维树：<br>通过在每一步探索多种推理可能性来扩展 CoT。它首先将问题分解为多个思考步骤，并在每个步骤中生成多个思考，从而创建树结构。搜索过程可以是 BFS（广度优先搜索）或 DFS（深度优先搜索），每个状态由分类器（通过提示）或多数投票进行评估。</p></li></ul><h2 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h2><ul><li><p>感知记忆：<br>这是记忆的最早阶段，提供在原始刺激结束后保留感觉信息（视觉、听觉等）印象的能力。感知记忆通常只能持续几秒钟。子类别包括图像记忆（视觉）、回声记忆（听觉）和触觉记忆（触摸）。感知记忆作为原始输入的学习嵌入表示，包括文本、图像或其他形式。</p></li><li><p>短期记忆：<br>它存储我们当前意识到的以及执行学习和推理等复杂认知任务所需的信息。短期记忆被认为具有大约 7 个项目的容量（Miller 1956）并且持续 20-30 秒。短期记忆作为情境学习。它是短且有限的，因为它受到 Transformer 有限上下文窗口长度的限制。</p></li><li><p>长期记忆（LTM）：<br>长期记忆可以存储相当长的时间信息，从几天到几十年不等，存储容量基本上是无限的。 LTM 有两种亚型：</p></li></ul><ol><li><p>外显&#x2F;陈述性记忆：这是对事实和事件的记忆，是指那些可以有意识地回忆起来的记忆，包括情景记忆（事件和经历）和语义记忆（事实和概念）。</p></li><li><p>内隐&#x2F;程序性记忆：这种类型的记忆是无意识的，涉及自动执行的技能和例程，例如骑自行车或在键盘上打字。</p></li></ol><p>长期记忆作为代理在查询时可以处理的外部向量存储，可通过快速检索进行访问。</p><h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><ul><li>代理学习调用外部 API 来获取模型权重中缺失的额外信息（通常在预训练后很难更改），包括当前信息、代码执行能力、对专有信息源的访问等。</li><li>API-Bank (Li et al. 2023) 是评估工具增强LLM性能的基准。它包含 53 个常用的 API 工具、一个完整的工具增强的 LLM 工作流程，以及涉及 568 个 API 调用的 264 个带注释的对话。API的选择非常多样化，包括搜索引擎，计算器，日历查询，智能家居控制，日程安排管理，健康数据管理，帐户身份验证工作流程等。因为有大量的API，LLM首先可以访问API搜索引擎找到合适的API调用，然后使用相应的文档进行调用。</li><li>清华发表的ToolLLM（Qin et al. 2023）中大模型能够使用的API高达16000多个。</li></ul>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2024/04/11/2024-04-11-1-LLM-Agent/agent-overview.png&quot; class=&quot;&quot; title=&quot;Agent Overview&quot;&gt;

&lt;h1 id=&quot;Agent介绍&quot;&gt;&lt;a href=&quot;#Agent介绍&quot; class=&quot;headerlink&quot; title=&quot;Agent介绍&quot;&gt;&lt;/a&gt;Agent介绍&lt;/h1&gt;&lt;h2 id=&quot;什么是-AI-代理&quot;&gt;&lt;a href=&quot;#什么是-AI-代理&quot; class=&quot;headerlink&quot; title=&quot;什么是 AI 代理&quot;&gt;&lt;/a&gt;什么是 AI 代理&lt;/h2&gt;&lt;p&gt;AI代理（AI agent）是指使用 AI 技术设计和编程的一种计算机程序，其可以独立地进行某些任务并对环境做出反应。AI代理可以被视为一个智能体，它能够感知其环境，通过自己的决策和行动来改变环境，并通过学习和适应来提高其性能。这种智能体同时使用短期记忆（上下文学习）和长期记忆（从外部向量存储中检索信息），有能力通过逐步“思考”来计划、将目标分解为更小的任务 ，并反思自己的表现。AI代理通常包含多种技术，如机器学习、自然语言处理、计算机视觉、规划和推理等，这些技术使代理能够自主地处理信息并作出决策。&lt;/p&gt;</summary>
    
    
    
    <category term="知识积累" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="llm" scheme="http://example.com/tags/llm/"/>
    
  </entry>
  
  <entry>
    <title>[2023-12-27] Flask #1:Flask简单使用</title>
    <link href="http://example.com/2023/12/27/2023-12-27-2-Flask%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/12/27/2023-12-27-2-Flask%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-27T14:58:25.000Z</published>
    <updated>2024-05-05T12:30:21.413Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/12/27/2023-12-27-2-Flask%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/flask.png" class="" title="Flask"><h1 id="Flask快速上手"><a href="#Flask快速上手" class="headerlink" title="Flask快速上手"></a>Flask快速上手</h1><h2 id="环境下载"><a href="#环境下载" class="headerlink" title="环境下载"></a>环境下载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask</span><br></pre></td></tr></table></figure><h2 id="Flask服务-Flask-Server"><a href="#Flask服务-Flask-Server" class="headerlink" title="Flask服务(Flask Server)"></a>Flask服务(Flask Server)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, send_file, make_response</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use CUDA</span></span><br><span class="line">os.environ[<span class="string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">os.environ[<span class="string">&#x27;CUDA_LAUNCH_BLOCKING&#x27;</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">use_cuda = torch.cuda.is_available()</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入模型</span></span><br><span class="line">model=...</span><br><span class="line">root_dir = ...</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root_dir):</span><br><span class="line">    os.makedirs(root_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义服务接口</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/predict_from_file&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>():</span><br><span class="line">    file = request.files.get(<span class="string">&#x27;file&#x27;</span>)  <span class="comment"># 获取上传的文件</span></span><br><span class="line">    <span class="keyword">if</span> file:</span><br><span class="line">        file.save(root_dir + <span class="string">&#x27;/&#x27;</span> + file.filename)  <span class="comment"># 将上传文件保存到本地</span></span><br><span class="line">        input_file = load(root_dir + <span class="string">&#x27;/&#x27;</span> + file.filename)  <span class="comment"># 读取本地文件</span></span><br><span class="line">        results = model.inference(input_file)  <span class="comment"># 对本地文件进行推理计算</span></span><br><span class="line">        <span class="comment"># 返回预测结果</span></span><br><span class="line">        <span class="keyword">return</span> make_response(results)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;No file uploaded&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义服务接口</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/get_file&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getresult</span>():</span><br><span class="line">    filename = request.args.get(<span class="string">&#x27;file&#x27;</span>)  <span class="comment"># 获取请求参数中的文件名</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filename:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Missing parameter: file&quot;</span>  <span class="comment"># 没有提供文件名</span></span><br><span class="line">    filepath = root_dir + <span class="string">&#x27;/&#x27;</span> + filename  <span class="comment"># 生成完整的文件路径</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> send_file(filepath, as_attachment=<span class="literal">True</span>, attachment_filename=filename)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The file does not exist&quot;</span>  <span class="comment"># 文件不存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Flask客户端-Flask-Client"><a href="#Flask客户端-Flask-Client" class="headerlink" title="Flask客户端(Flask Client)"></a>Flask客户端(Flask Client)</h2>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2023/12/27/2023-12-27-2-Flask%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/flask.png&quot; class=&quot;&quot; title=&quot;Flask&quot;&gt;

&lt;h1 id=&quot;Flask快速上手&quot;&gt;&lt;a href=&quot;#Flask快速上手&quot; class=&quot;headerlink&quot; title=&quot;Flask快速上手&quot;&gt;&lt;/a&gt;Flask快速上手&lt;/h1&gt;&lt;h2 id=&quot;环境下载&quot;&gt;&lt;a href=&quot;#环境下载&quot; class=&quot;headerlink&quot; title=&quot;环境下载&quot;&gt;&lt;/a&gt;环境下载&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install flask&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;Flask服务-Flask-Server&quot;&gt;&lt;a href=&quot;#Flask服务-Flask-Server&quot; class=&quot;headerlink&quot; title=&quot;Flask服务(Flask Server)&quot;&gt;&lt;/a&gt;Flask服务(Flask Server)&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Flask, request, send_file, make_response&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; model &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; torch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; cv2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Use CUDA&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os.environ[&lt;span class=&quot;string&quot;&gt;&amp;#x27;CUDA_VISIBLE_DEVICES&amp;#x27;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os.environ[&lt;span class=&quot;string&quot;&gt;&amp;#x27;CUDA_LAUNCH_BLOCKING&amp;#x27;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;use_cuda = torch.cuda.is_available()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app = Flask(__name__)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 载入模型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model=...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root_dir = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; os.path.exists(root_dir):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    os.makedirs(root_dir)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 定义服务接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@app.route(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#x27;/predict_from_file&amp;#x27;&lt;/span&gt;, methods=[&lt;span class=&quot;string&quot;&gt;&amp;#x27;POST&amp;#x27;&lt;/span&gt;]&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;predict&lt;/span&gt;():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    file = request.files.get(&lt;span class=&quot;string&quot;&gt;&amp;#x27;file&amp;#x27;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# 获取上传的文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; file:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        file.save(root_dir + &lt;span class=&quot;string&quot;&gt;&amp;#x27;/&amp;#x27;&lt;/span&gt; + file.filename)  &lt;span class=&quot;comment&quot;&gt;# 将上传文件保存到本地&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        input_file = load(root_dir + &lt;span class=&quot;string&quot;&gt;&amp;#x27;/&amp;#x27;&lt;/span&gt; + file.filename)  &lt;span class=&quot;comment&quot;&gt;# 读取本地文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        results = model.inference(input_file)  &lt;span class=&quot;comment&quot;&gt;# 对本地文件进行推理计算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 返回预测结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; make_response(results)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;No file uploaded&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 定义服务接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@app.route(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#x27;/get_file&amp;#x27;&lt;/span&gt;, methods=[&lt;span class=&quot;string&quot;&gt;&amp;#x27;GET&amp;#x27;&lt;/span&gt;]&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;getresult&lt;/span&gt;():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    filename = request.args.get(&lt;span class=&quot;string&quot;&gt;&amp;#x27;file&amp;#x27;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# 获取请求参数中的文件名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; filename:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Missing parameter: file&amp;quot;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 没有提供文件名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    filepath = root_dir + &lt;span class=&quot;string&quot;&gt;&amp;#x27;/&amp;#x27;&lt;/span&gt; + filename  &lt;span class=&quot;comment&quot;&gt;# 生成完整的文件路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; send_file(filepath, as_attachment=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;, attachment_filename=filename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; FileNotFoundError:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;The file does not exist&amp;quot;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 文件不存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&amp;#x27;__main__&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.run(host=&lt;span class=&quot;string&quot;&gt;&amp;#x27;0.0.0.0&amp;#x27;&lt;/span&gt;, port=&lt;span class=&quot;number&quot;&gt;8000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术积累" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="Code" scheme="http://example.com/tags/Code/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Flask" scheme="http://example.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>[2023-09-22] Docker #3:Docker容器操作</title>
    <link href="http://example.com/2023/09/22/2023-09-22-Docker-3-Docker%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2023/09/22/2023-09-22-Docker-3-Docker%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2023-09-22T15:19:10.000Z</published>
    <updated>2023-09-22T15:54:34.586Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/09/22/2023-09-22-Docker-3-Docker%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/contaner.png" class="" title="Vim"><h1 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h1><h2 id="1-启动容器"><a href="#1-启动容器" class="headerlink" title="1. 启动容器"></a>1. 启动容器</h2><p>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>-i</strong>: 交互式操作。</li><li><strong>-t</strong>: 终端。</li><li><strong>ubuntu</strong>: ubuntu 镜像。</li><li><strong>&#x2F;bin&#x2F;bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</li></ul><p>要退出终端，直接输入 <strong>exit</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ed09e4490c57:/<span class="comment"># exit</span></span><br></pre></td></tr></table></figure>  <span id="more"></span><h3 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h3><p>查看所有的容器命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure><p>使用 docker start 启动一个已停止的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start b750bbbcfd88 </span><br></pre></td></tr></table></figure><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name ubuntu-test ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p><strong>注：</strong>加了 <strong>-d</strong> 参数默认不会进入容器，想要进入容器需要使用指令 <strong>docker exec</strong></p><h3 id="停止一个容器"><a href="#停止一个容器" class="headerlink" title="停止一个容器"></a>停止一个容器</h3><p>停止容器的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure><p>停止的容器可以通过 docker restart 重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker restart &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure><h2 id="2-进入容器"><a href="#2-进入容器" class="headerlink" title="2. 进入容器"></a>2. 进入容器</h2><p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p><ul><li><strong>docker attach</strong></li><li><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此命令会退出容器终端，但不会导致容器的停止。</li></ul><h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h3><p>下面演示了使用 docker attach 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach 1e560fca3906 </span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果从这个容器退出，会导致容器的停止。</p><h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a>exec 命令</h3><p>下面演示了使用 docker exec 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -it 243c32535da7 /bin/bash</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用 <strong>docker exec</strong> 的原因。</p><p>更多参数说明请使用 <strong>docker exec –help</strong> 命令查看。</p><h2 id="3-导出和导入容器"><a href="#3-导出和导入容器" class="headerlink" title="3. 导出和导入容器"></a>3. 导出和导入容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <strong>docker export</strong> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">export</span> 1e560fca3906 &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。</p><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test&#x2F;ubuntu:v1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> docker/ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1</span><br></pre></td></tr></table></figure><h3 id="容器保存为镜像"><a href="#容器保存为镜像" class="headerlink" title="容器保存为镜像"></a>容器保存为镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器保存为镜像</span></span><br><span class="line"><span class="variable">$docker</span> commit [CONTAINER ID] [IMAGE NAME]   <span class="comment">#容器ID  创建的镜像名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 docker save 命令根据 ID 将镜像保存成一个文件</span></span><br><span class="line">$ docker save 0fdf2b4c26d3 &gt; hangge_server.tar</span><br><span class="line"><span class="comment"># 还可以同时将多个 image 打包成一个文件，比如下面将镜像库中的 postgres 和 mongo 打包</span></span><br><span class="line">$ docker save -o images.tar postgres:9.6 mongo:3.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 docker load 命令则可将这个镜像文件载入进来</span></span><br><span class="line">$ docker load &lt; hangge_server.tar</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2023/09/22/2023-09-22-Docker-3-Docker%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/contaner.png&quot; class=&quot;&quot; title=&quot;Vim&quot;&gt;


&lt;h1 id=&quot;容器命令&quot;&gt;&lt;a href=&quot;#容器命令&quot; class=&quot;headerlink&quot; title=&quot;容器命令&quot;&gt;&lt;/a&gt;容器命令&lt;/h1&gt;&lt;h2 id=&quot;1-启动容器&quot;&gt;&lt;a href=&quot;#1-启动容器&quot; class=&quot;headerlink&quot; title=&quot;1. 启动容器&quot;&gt;&lt;/a&gt;1. 启动容器&lt;/h2&gt;&lt;p&gt;以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker run -it ubuntu /bin/bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-i&lt;/strong&gt;: 交互式操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-t&lt;/strong&gt;: 终端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ubuntu&lt;/strong&gt;: ubuntu 镜像。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;#x2F;bin&amp;#x2F;bash&lt;/strong&gt;：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &amp;#x2F;bin&amp;#x2F;bash。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要退出终端，直接输入 &lt;strong&gt;exit&lt;/strong&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root@ed09e4490c57:/&lt;span class=&quot;comment&quot;&gt;# exit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术积累" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="Code" scheme="http://example.com/tags/Code/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>[2023-09-14] Docker #2:Docker镜像操作</title>
    <link href="http://example.com/2023/09/15/2023-09-14-Docker-2-Docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2023/09/15/2023-09-14-Docker-2-Docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/</id>
    <published>2023-09-14T16:15:23.000Z</published>
    <updated>2023-09-14T16:16:14.816Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/09/15/2023-09-14-Docker-2-Docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/docker_image.jpg" class="" title="Docker"><h1 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h1><h2 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2. 列出镜像"></a>2. 列出镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.显示顶层镜像</span></span><br><span class="line">$ docker images </span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.显示中间层镜像</span></span><br><span class="line">$ docker images -a</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.只显示镜像ID</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> -q</span><br><span class="line">5f515359c7f8</span><br><span class="line">05a60462f8ba</span><br><span class="line">fe9198c04d62</span><br><span class="line">00285df0df87</span><br><span class="line">329ed837d508</span><br><span class="line">329ed837d508</span><br></pre></td></tr></table></figure><h2 id="3-运行镜像"><a href="#3-运行镜像" class="headerlink" title="3. 运行镜像"></a>3. 运行镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p><strong>OPTIONS说明：</strong></p><p>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>-d: 后台运行容器，并返回容器ID；</p><p>-i: 以交互模式运行容器，通常与 -t 同时使用；</p><p>-P: 随机端口映射，容器内部端口随机映射到主机的端口</p><p>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口</p><p>–name&#x3D;”nginx-lb”: 为容器指定一个名称；</p><p>–volume , -v: 绑定一个卷</p><p><strong>实例</strong></p><ul><li>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure><ul><li>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -P -d nginx:latest</span><br></pre></td></tr></table></figure><ul><li>使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 &#x2F;data 映射到容器的 &#x2F;data。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br></pre></td></tr></table></figure><ul><li>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br></pre></td></tr></table></figure><ul><li>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行&#x2F;bin&#x2F;bash命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@b8573233d675:/<span class="comment"># </span></span><br></pre></td></tr></table></figure><h2 id="4-删除镜像"><a href="#4-删除镜像" class="headerlink" title="4. 删除镜像"></a>4. 删除镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br><span class="line"><span class="comment"># or </span></span><br><span class="line">$ docker rmi &lt;image1&gt; [&lt;image2&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除仓库名为redis的镜像</span></span><br><span class="line">$ docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -q redis)</span><br><span class="line"><span class="comment"># 删除所有在 mongo:3.2 之前的镜像：</span></span><br><span class="line">$ docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><h2 id="5-保存镜像"><a href="#5-保存镜像" class="headerlink" title="5. 保存镜像"></a>5. 保存镜像</h2><ul><li><code>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code>: 从运行的容器中保存</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 运行一个容器</span></span><br><span class="line"><span class="comment"># 这条命令会用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器。</span></span><br><span class="line">$ docker run --name webserver -d -p 80:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入容器，进行修改</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it webserver bash</span><br><span class="line">root@3729b97e8226:/<span class="comment"># echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root@3729b97e8226:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 执行 docker commit 命令将修改后的容器保存为新的镜像</span></span><br><span class="line">$ docker commit \</span><br><span class="line">    --author <span class="string">&quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot;</span> \</span><br><span class="line">    --message <span class="string">&quot;修改了默认网页&quot;</span> \</span><br><span class="line">    webserver \</span><br><span class="line">    nginx:v2</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure><h2 id="6-镜像导出和导入-保存和载入"><a href="#6-镜像导出和导入-保存和载入" class="headerlink" title="6. 镜像导出和导入&#x2F;保存和载入"></a>6. 镜像导出和导入&#x2F;保存和载入</h2><ul><li><code>docker export; docker import</code> 或者<code>docker save; docker load</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1</span></span><br><span class="line"><span class="comment"># 使用 docker export 命令根据容器 ID 将镜像导出成一个文件</span></span><br><span class="line">$ docker <span class="built_in">export</span> f299f501774c &gt; hangger_server.tar</span><br><span class="line"><span class="comment"># 使用 docker import 命令则可将这个镜像文件导入进来</span></span><br><span class="line">$ docker import - new_hangger_server &lt; hangger_server.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="comment"># 使用 docker save 命令根据 ID 将镜像保存成一个文件</span></span><br><span class="line">$ docker save 0fdf2b4c26d3 &gt; hangge_server.tar</span><br><span class="line"><span class="comment"># 还可以同时将多个 image 打包成一个文件，比如下面将镜像库中的 postgres 和 mongo 打包</span></span><br><span class="line">$ docker save -o images.tar postgres:9.6 mongo:3.4</span><br><span class="line"><span class="comment"># 使用 docker load 命令则可将这个镜像文件载入进来</span></span><br><span class="line">$ docker load &lt; hangge_server.tar</span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li><code>docker export; docker import</code>或<code>docker save; docker load</code>必须成对使用</li><li><strong>docker export 的应用场景</strong>：主要用来制作基础镜像，比如我们从一个 <strong>ubuntu</strong> 镜像启动一个容器，然后安装一些软件和进行一些设置后，使用 <strong>docker export</strong> 保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</li><li><strong>docker save 的应用场景</strong>：如果我们的应用是使用 <strong>docker-compose.yml</strong> 编排的多个镜像组合，但我们要部署的客户服务器并不能连外网。这时就可以使用 <strong>docker save</strong> 将用到的镜像打个包，然后拷贝到客户服务器上使用 <strong>docker load</strong> 载入。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2023/09/15/2023-09-14-Docker-2-Docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C/docker_image.jpg&quot; class=&quot;&quot; title=&quot;Docker&quot;&gt;

&lt;h1 id=&quot;镜像命令&quot;&gt;&lt;a href=&quot;#镜像命令&quot; class=&quot;headerlink&quot; title=&quot;镜像命令&quot;&gt;&lt;/a&gt;镜像命令&lt;/h1&gt;&lt;h2 id=&quot;1-获取镜像&quot;&gt;&lt;a href=&quot;#1-获取镜像&quot; class=&quot;headerlink&quot; title=&quot;1. 获取镜像&quot;&gt;&lt;/a&gt;1. 获取镜像&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术积累" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="Code" scheme="http://example.com/tags/Code/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>[2023-09-13] Docker #1:认识Docker</title>
    <link href="http://example.com/2023/09/13/2023-09-13-Docker-1-%E8%AE%A4%E8%AF%86Docker/"/>
    <id>http://example.com/2023/09/13/2023-09-13-Docker-1-%E8%AE%A4%E8%AF%86Docker/</id>
    <published>2023-09-13T12:19:15.000Z</published>
    <updated>2023-09-13T12:35:41.540Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/09/13/2023-09-13-Docker-1-%E8%AE%A4%E8%AF%86Docker/docker.jpg" class="" title="Docker"><h1 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h1><p>Docker 是一个开源的应用容器引擎，基于 [Go 语言] 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><span id="more"></span><h2 id="Docker应用场景"><a href="#Docker应用场景" class="headerlink" title="Docker应用场景"></a>Docker应用场景</h2><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery&#x2F;Deployment)</a> 系统进行自动部署。</p><p>而且使用 <a href=""><code>Dockerfile</code></a> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&image_filter=official">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><h1 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h1><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p><h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="">数据卷（Volume）</a>、或者 <a href="">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2023/09/13/2023-09-13-Docker-1-%E8%AE%A4%E8%AF%86Docker/docker.jpg&quot; class=&quot;&quot; title=&quot;Docker&quot;&gt;

&lt;h1 id=&quot;Docker介绍&quot;&gt;&lt;a href=&quot;#Docker介绍&quot; class=&quot;headerlink&quot; title=&quot;Docker介绍&quot;&gt;&lt;/a&gt;Docker介绍&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 [Go 语言] 并遵从 Apache2.0 协议开源。&lt;/p&gt;
&lt;p&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;</summary>
    
    
    
    <category term="技术积累" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="Code" scheme="http://example.com/tags/Code/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>[2023-09-09] Linux #1:Vim编辑器</title>
    <link href="http://example.com/2023/09/09/2023-09-09-Linux-1-Vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://example.com/2023/09/09/2023-09-09-Linux-1-Vim%E7%BC%96%E8%BE%91%E5%99%A8/</id>
    <published>2023-09-09T14:12:46.000Z</published>
    <updated>2024-04-10T16:10:00.846Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/09/09/2023-09-09-Linux-1-Vim%E7%BC%96%E8%BE%91%E5%99%A8/vim.png" class="" title="Vim"><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a><code>Vim</code></h1><h2 id="Vim介绍"><a href="#Vim介绍" class="headerlink" title="Vim介绍"></a><code>Vim</code>介绍</h2><p>VIM 是 Linux 系统上一款文本编辑器，它是操作 Linux 的一款利器。</p><h3 id="Vim-常用的四个模式："><a href="#Vim-常用的四个模式：" class="headerlink" title="Vim 常用的四个模式："></a><code>Vim</code> 常用的四个模式：</h3><ul><li><p>正常模式 (Normal-mode)</p><p>一般用于浏览文件，也包括一些复制、粘贴、删除等操作。这时击键时，一些组合键就是<code>vim</code>的功能键，而不会在文本中键入对应的字符。</p></li><li><p>插入模式 (Insert-mode)</p><p>简单的来说，就是编辑文本的模式。</p></li><li><p>命令模式 (Command-mode)</p><p>在正常模式中，按下<code>:</code>（冒号）键或者<code>/</code> （斜杠），会进入命令模式。在命令模式中可以执行一些输入并执行一些 VIM 或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。</p></li><li><p>可视模式 (Visual-mode)</p><p>在正常模式按下<code>v, V, &lt;Ctrl&gt;+v</code>，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。</p><span id="more"></span></li></ul><h2 id="Vim使用"><a href="#Vim使用" class="headerlink" title="Vim使用"></a><code>Vim</code>使用</h2><h3 id="文件打开、切换、保存"><a href="#文件打开、切换、保存" class="headerlink" title="文件打开、切换、保存"></a>文件打开、切换、保存</h3><table><thead><tr><th>文件外命令</th><th>文件内命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>vim file1</td><td></td><td>打开file1文件</td><td>打开单个文件</td></tr><tr><td>vim file1 file2 …</td><td></td><td>打开file1,file2文件</td><td>打开多个文件</td></tr><tr><td></td><td>:ls</td><td>列出Vim打开的所有文件</td><td>在上述打开多个文件的基础上使用</td></tr><tr><td></td><td>:b2</td><td>在显示屏上显示第2个文件</td><td>切换到第2个文件显示</td></tr><tr><td>vim -On file1 file2 …</td><td></td><td>左右分屏显示多个文件</td><td></td></tr><tr><td>vim -on file1 file2 …</td><td></td><td>上下分屏显示多个文件</td><td></td></tr><tr><td></td><td>Ctrl+w s</td><td>上下分割当前打开的所有文件</td><td>在打开多个文件的基础上使用</td></tr><tr><td></td><td>:sp file</td><td>上下分割当前文件和新打开的文件</td><td></td></tr><tr><td></td><td>Ctrl+w v</td><td>左右分割当前打开的所有文件</td><td>在打开多个文件的基础上使用</td></tr><tr><td></td><td>:vsp file</td><td>左右分割当前文件和新打开的文件</td><td></td></tr><tr><td></td><td>Ctrl+w h</td><td>将当前光标移动到左边的分屏</td><td></td></tr><tr><td></td><td>Ctrl+w l</td><td>将当前光标移动到右边的分屏</td><td></td></tr><tr><td></td><td>Ctrl+w H</td><td>将当前光标所在分屏移动到左边</td><td></td></tr><tr><td></td><td>Ctrl+w L</td><td>将当前光标所在分屏移动到右边</td><td></td></tr><tr><td></td><td>Ctrl+w j</td><td>将当前光标移动到下边的分屏</td><td></td></tr><tr><td></td><td>Ctrl+w k</td><td>将当前光标移动到上边的分屏</td><td></td></tr><tr><td></td><td>Ctrl+w J</td><td>将当前光标所在分屏移动到上边</td><td></td></tr><tr><td></td><td>Ctrl+w K</td><td>将当前光标所在分屏移动到下边</td><td></td></tr><tr><td></td><td>:w</td><td>保存当前对文件的修改，但是不退出文件</td><td></td></tr><tr><td></td><td>:w!</td><td>强制保存但是不退出文件</td><td></td></tr><tr><td></td><td>:w file</td><td>保存当前的文件修改到 file 文件当中</td><td></td></tr><tr><td></td><td>:q!</td><td>退出文件，对文件的修改不做保存</td><td></td></tr><tr><td></td><td>:qa!</td><td>退出所有的文件并不做保存</td><td></td></tr><tr><td></td><td>:wq</td><td>退出文件并保存对文件的修改</td><td></td></tr><tr><td></td><td>:x</td><td>退出文件并保存对文件的修改</td><td></td></tr><tr><td></td><td>:e file</td><td>打开另一个文件</td><td></td></tr><tr><td></td><td>:e!</td><td>放弃对文件的所有修改，恢复文件到上次保存的位置</td><td></td></tr><tr><td></td><td>:saveas file</td><td>另存为 file</td><td></td></tr><tr><td></td><td>:bn<code>和</code>:bp</td><td><code>:bn</code> 和 <code>:bp</code> 进行上一个文件或者下一个文件的切换</td><td></td></tr></tbody></table><h3 id="文件编辑"><a href="#文件编辑" class="headerlink" title="文件编辑"></a>文件编辑</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>在光标所在的字符之前插入需要录入的文本</td></tr><tr><td><code>I</code></td><td>在光标所在行的行首插入需要录入的文本</td></tr><tr><td><code>a</code></td><td>在光标所在的字符之后插入需要录入的文本</td></tr><tr><td><code>A</code></td><td>在光标所在行的行尾插入需要录入的文本</td></tr><tr><td><code>o</code></td><td>光标所在行的下一行行首插入需要录入的文本</td></tr><tr><td><code>O</code></td><td>光标所在行的上一行行首插入需要录入的文本</td></tr><tr><td><code>s</code></td><td>删除光标所在处的字符然后插入需要录入的文本</td></tr><tr><td><code>S</code></td><td>删除光标所在行，在当前行的行首开始插入需要录入的文本</td></tr></tbody></table><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>向左移动</td></tr><tr><td>j</td><td>向下移动</td></tr><tr><td>k</td><td>向上移动</td></tr><tr><td>l</td><td>向右移动</td></tr><tr><td><code>0 </code></td><td>移动到行头</td></tr><tr><td><code>^</code></td><td>移动到本行的第一个不是 blank 字符</td></tr><tr><td><code>$</code></td><td>移动到行尾</td></tr><tr><td><code>g_</code></td><td>移动到本行最后一个不是 blank 字符的位置</td></tr><tr><td><code>w</code></td><td>光标移动到下一个单词的开头</td></tr><tr><td><code>e</code></td><td>光标移动到下一个单词的结尾</td></tr><tr><td><code>b</code></td><td>光标移动到上一个单词的开头</td></tr><tr><td><code>fa</code></td><td>移动到本行下一个为 a 的字符处</td></tr><tr><td><code>nG </code></td><td>光标定位到第 n 行的行首</td></tr><tr><td><code>gg </code></td><td>光标定位到第一行的行首</td></tr><tr><td><code>G </code></td><td>光标定位到最后一行的行首</td></tr><tr><td><code>H </code></td><td>光标定位到当前屏幕的第一行行首</td></tr><tr><td><code>M</code></td><td>光标移动到当前屏幕的中间</td></tr><tr><td><code>L</code></td><td>光标移动到当前屏幕的尾部</td></tr><tr><td><code>zt</code></td><td>把当前行移动到当前屏幕的最上方，也就是第一行</td></tr><tr><td><code>zz</code></td><td>把当前行移动到当前屏幕的中间</td></tr><tr><td><code>zb</code></td><td>把当前行移动到当前屏幕的尾部</td></tr><tr><td><code>%</code></td><td>匹配括号移动，包括 ( , { , [ 需要把光标先移动到括号上</td></tr><tr><td><code>*</code></td><td>匹配光标当前所在的单词，移动光标到下一个匹配的单词</td></tr><tr><td><code>#</code></td><td>匹配光标当前所在的单词，移动光标到上一个匹配的单词</td></tr></tbody></table><h3 id="翻页操作"><a href="#翻页操作" class="headerlink" title="翻页操作"></a>翻页操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>ctrl+f</code></td><td>查看下一页内容</td></tr><tr><td><code>ctrl+b</code></td><td>查看上一页内容</td></tr></tbody></table><h3 id="撤销和恢复"><a href="#撤销和恢复" class="headerlink" title="撤销和恢复"></a>撤销和恢复</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>u</code></td><td>撤销刚才的操作</td></tr><tr><td><code>ctrl + r</code></td><td>恢复撤销操作</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2023/09/09/2023-09-09-Linux-1-Vim%E7%BC%96%E8%BE%91%E5%99%A8/vim.png&quot; class=&quot;&quot; title=&quot;Vim&quot;&gt;
&lt;h1 id=&quot;Vim&quot;&gt;&lt;a href=&quot;#Vim&quot; class=&quot;headerlink&quot; title=&quot;Vim&quot;&gt;&lt;/a&gt;&lt;code&gt;Vim&lt;/code&gt;&lt;/h1&gt;&lt;h2 id=&quot;Vim介绍&quot;&gt;&lt;a href=&quot;#Vim介绍&quot; class=&quot;headerlink&quot; title=&quot;Vim介绍&quot;&gt;&lt;/a&gt;&lt;code&gt;Vim&lt;/code&gt;介绍&lt;/h2&gt;&lt;p&gt;VIM 是 Linux 系统上一款文本编辑器，它是操作 Linux 的一款利器。&lt;/p&gt;
&lt;h3 id=&quot;Vim-常用的四个模式：&quot;&gt;&lt;a href=&quot;#Vim-常用的四个模式：&quot; class=&quot;headerlink&quot; title=&quot;Vim 常用的四个模式：&quot;&gt;&lt;/a&gt;&lt;code&gt;Vim&lt;/code&gt; 常用的四个模式：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正常模式 (Normal-mode)&lt;/p&gt;
&lt;p&gt;一般用于浏览文件，也包括一些复制、粘贴、删除等操作。这时击键时，一些组合键就是&lt;code&gt;vim&lt;/code&gt;的功能键，而不会在文本中键入对应的字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;插入模式 (Insert-mode)&lt;/p&gt;
&lt;p&gt;简单的来说，就是编辑文本的模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令模式 (Command-mode)&lt;/p&gt;
&lt;p&gt;在正常模式中，按下&lt;code&gt;:&lt;/code&gt;（冒号）键或者&lt;code&gt;/&lt;/code&gt; （斜杠），会进入命令模式。在命令模式中可以执行一些输入并执行一些 VIM 或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可视模式 (Visual-mode)&lt;/p&gt;
&lt;p&gt;在正常模式按下&lt;code&gt;v, V, &amp;lt;Ctrl&amp;gt;+v&lt;/code&gt;，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。&lt;/p&gt;</summary>
    
    
    
    <category term="技术积累" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>[2023-09-09] Python #1:Pdb调试器</title>
    <link href="http://example.com/2023/09/09/2023-09-09-Python-1-Pdb%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    <id>http://example.com/2023/09/09/2023-09-09-Python-1-Pdb%E8%B0%83%E8%AF%95%E5%99%A8/</id>
    <published>2023-09-09T09:56:09.000Z</published>
    <updated>2023-09-13T12:24:16.976Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/09/09/2023-09-09-Python-1-Pdb%E8%B0%83%E8%AF%95%E5%99%A8/pdb.png" class="" title="Pdb"><h1 id="Pdb介绍"><a href="#Pdb介绍" class="headerlink" title="Pdb介绍"></a>Pdb介绍</h1><p><strong>网址</strong>:<a href="https://docs.python.org/3/library/pdb.html">pdb — The Python Debugger</a></p><p><strong>介绍</strong>:模块pdb为Python程序定义了一个交互式源代码调试器。它支持在源行级别设置（条件）断点和单步执行，检查堆栈帧，列出源代码，以及在任何堆栈帧的上下文中评估任意Python代码。它还支持死后调试，并且可以在程序控制下调用。</p><span id="more"></span><h1 id="Pdb用法"><a href="#Pdb用法" class="headerlink" title="Pdb用法"></a>Pdb用法</h1><ul><li><strong>非侵入式方法</strong>（不用额外修改源代码，在命令行下直接运行就能调试）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pdb filename.py</span><br></pre></td></tr></table></figure><ul><li><strong>侵入式方法</strong>（需要在被调试的代码中添加一行代码然后再正常运行代码）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb;pdb.set_trace()</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">pdb.set_trace()</span><br></pre></td></tr></table></figure><h1 id="Pdb常用命令"><a href="#Pdb常用命令" class="headerlink" title="Pdb常用命令"></a>Pdb常用命令</h1><table><thead><tr><th align="left">完整命令</th><th align="left">命令</th><th align="left">解释</th><th>说明</th></tr></thead><tbody><tr><td align="left">list</td><td align="left">l</td><td align="left">查看当前行的代码段</td><td>查看当前位置前后11行源代码（多次会翻页），当前位置在代码中会用–&gt;这个符号标出来</td></tr><tr><td align="left"></td><td align="left">ll</td><td align="left">查看当前函数或框架的所有源代码</td><td></td></tr><tr><td align="left">break</td><td align="left">b</td><td align="left">设置断点</td><td></td></tr><tr><td align="left"></td><td align="left">b lineno</td><td align="left">在lineno行设置断点</td><td></td></tr><tr><td align="left"></td><td align="left">b filename:lineno</td><td align="left">filename文件名，在filename的lineno行设置断点</td><td></td></tr><tr><td align="left"></td><td align="left">b functionname</td><td align="left">在函数名执行的第一行设置断点</td><td></td></tr><tr><td align="left">tbreak</td><td align="left">\</td><td align="left">临时断点，执行一次后时自动删除（这就是它被称为临时断点的原因）</td><td>参数同break，b</td></tr><tr><td align="left">clear</td><td align="left">cl</td><td align="left">清除所有断点</td><td>1.不带参数用于清除所有断点，会提示确认（包括临时断点）<br/>2.带参数则清除指定文件行或当前文件指定序号的断点</td></tr><tr><td align="left"></td><td align="left">cl filename:lineno</td><td align="left">清除指定文件中的指定行号的断点</td><td>filename: 文件名<br/>lineno: 断点行号</td></tr><tr><td align="left"></td><td align="left">cl bpnumber [bpnumber …]</td><td align="left">清除当前文件中的一个或多个断点</td><td>bpnumber: break point number 断点行号。bpnumber 断点序号（多个以空格分隔）</td></tr><tr><td align="left">print</td><td align="left">p x</td><td align="left">打印变量x的值</td><td></td></tr><tr><td align="left">step</td><td align="left">s</td><td align="left">进入函数（能够进入函数体）（进入 for 循环用 next 而不是用 step）</td><td></td></tr><tr><td align="left">next</td><td align="left">n</td><td align="left">执行下一行（不会进入函数体）</td><td></td></tr><tr><td align="left">return</td><td align="left">r</td><td align="left">执行下一行（在函数中时会直接执行到函数返回处）</td><td></td></tr><tr><td align="left">continue</td><td align="left">c</td><td align="left">持续执行下去，直到遇到一个断点</td><td></td></tr><tr><td align="left">until</td><td align="left">unt lineno</td><td align="left">持续执行直到运行到指定行（或遇到断点）</td><td></td></tr><tr><td align="left">jump</td><td align="left">j lineno</td><td align="left">直接跳转到指定行（注意，被跳过的代码不执行）</td><td></td></tr><tr><td align="left">up</td><td align="left">u</td><td align="left">返回到上个调用点（不是上一行）</td><td></td></tr><tr><td align="left">args</td><td align="left">a</td><td align="left">在函数中时打印函数的参数和参数的值</td><td></td></tr><tr><td align="left">whatis</td><td align="left">whatis expression</td><td align="left">打印表达式的类型，常用来打印变量值</td><td></td></tr><tr><td align="left">where</td><td align="left">w</td><td align="left">打印堆栈信息，最新的帧在最底部。箭头表示当前帧。</td><td></td></tr><tr><td align="left">!</td><td align="left">\</td><td align="left">在pdb中执行语句</td><td></td></tr><tr><td align="left">exit</td><td align="left">q</td><td align="left">中止调试，退出程序</td><td></td></tr><tr><td align="left">help</td><td align="left">\</td><td align="left">帮助</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2023/09/09/2023-09-09-Python-1-Pdb%E8%B0%83%E8%AF%95%E5%99%A8/pdb.png&quot; class=&quot;&quot; title=&quot;Pdb&quot;&gt;

&lt;h1 id=&quot;Pdb介绍&quot;&gt;&lt;a href=&quot;#Pdb介绍&quot; class=&quot;headerlink&quot; title=&quot;Pdb介绍&quot;&gt;&lt;/a&gt;Pdb介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;网址&lt;/strong&gt;:&lt;a href=&quot;https://docs.python.org/3/library/pdb.html&quot;&gt;pdb — The Python Debugger&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;:模块pdb为Python程序定义了一个交互式源代码调试器。它支持在源行级别设置（条件）断点和单步执行，检查堆栈帧，列出源代码，以及在任何堆栈帧的上下文中评估任意Python代码。它还支持死后调试，并且可以在程序控制下调用。&lt;/p&gt;</summary>
    
    
    
    <category term="技术积累" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="Code" scheme="http://example.com/tags/Code/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
</feed>
