<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of TheChef</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-13T12:23:51.526Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TheChef</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[2023-09-13] Docker #1:认识Docker</title>
    <link href="http://example.com/2023/09/13/2023-09-13-Docker-1-%E8%AE%A4%E8%AF%86Docker/"/>
    <id>http://example.com/2023/09/13/2023-09-13-Docker-1-%E8%AE%A4%E8%AF%86Docker/</id>
    <published>2023-09-13T12:19:15.000Z</published>
    <updated>2023-09-13T12:23:51.526Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/09/13/2023-09-13-Docker-1-%E8%AE%A4%E8%AF%86Docker/docker.jpg" class="" title="Docker"><h1 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h1><p>Docker 是一个开源的应用容器引擎，基于 [Go 语言] 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><span id="more"></span><h2 id="Docker应用场景"><a href="#Docker应用场景" class="headerlink" title="Docker应用场景"></a>Docker应用场景</h2><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery&#x2F;Deployment)</a> 系统进行自动部署。</p><p>而且使用 <a href=""><code>Dockerfile</code></a> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&image_filter=official">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><h1 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h1><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p><h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="">数据卷（Volume）</a>、或者 <a href="">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2023/09/13/2023-09-13-Docker-1-%E8%AE%A4%E8%AF%86Docker/docker.jpg&quot; class=&quot;&quot; title=&quot;Docker&quot;&gt;

&lt;h1 id=&quot;Docker介绍&quot;&gt;&lt;a href=&quot;#Docker介绍&quot; class=&quot;headerlink&quot; title=&quot;Docker介绍&quot;&gt;&lt;/a&gt;Docker介绍&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 [Go 语言] 并遵从 Apache2.0 协议开源。&lt;/p&gt;
&lt;p&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;</summary>
    
    
    
    <category term="技术积累" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="Code" scheme="http://example.com/tags/Code/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>[2023-09-09] Linux #1:Vim编辑器</title>
    <link href="http://example.com/2023/09/09/2023-09-09-Linux-1-Vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://example.com/2023/09/09/2023-09-09-Linux-1-Vim%E7%BC%96%E8%BE%91%E5%99%A8/</id>
    <published>2023-09-09T14:12:46.000Z</published>
    <updated>2023-09-13T12:25:15.188Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/09/09/2023-09-09-Linux-1-Vim%E7%BC%96%E8%BE%91%E5%99%A8/vim.png" class="" title="Vim"><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a><code>Vim</code></h1><h2 id="Vim介绍"><a href="#Vim介绍" class="headerlink" title="Vim介绍"></a><code>Vim</code>介绍</h2><p>VIM 是 Linux 系统上一款文本编辑器，它是操作 Linux 的一款利器。</p><h3 id="Vim-常用的四个模式："><a href="#Vim-常用的四个模式：" class="headerlink" title="Vim 常用的四个模式："></a><code>Vim</code> 常用的四个模式：</h3><ul><li><p>正常模式 (Normal-mode)</p><p>一般用于浏览文件，也包括一些复制、粘贴、删除等操作。这时击键时，一些组合键就是<code>vim</code>的功能键，而不会在文本中键入对应的字符。</p></li><li><p>插入模式 (Insert-mode)</p><p>简单的来说，就是编辑文本的模式。</p></li><li><p>命令模式 (Command-mode)</p><p>在正常模式中，按下<code>:</code>（冒号）键或者<code>/</code> （斜杠），会进入命令模式。在命令模式中可以执行一些输入并执行一些 VIM 或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。</p></li><li><p>可视模式 (Visual-mode)</p><p>在正常模式按下<code>v, V, &lt;Ctrl&gt;+v</code>，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。</p><span id="more"></span></li></ul><h2 id="Vim使用"><a href="#Vim使用" class="headerlink" title="Vim使用"></a><code>Vim</code>使用</h2><h3 id="文件打开、切换、保存"><a href="#文件打开、切换、保存" class="headerlink" title="文件打开、切换、保存"></a>文件打开、切换、保存</h3><table><thead><tr><th>文件外命令</th><th>文件内命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>vim file1</td><td></td><td>打开file1文件</td><td>打开单个文件</td></tr><tr><td>vim file1 file2 …</td><td></td><td>打开file1,file2文件</td><td>打开多个文件</td></tr><tr><td></td><td>:ls</td><td>列出Vim打开的所有文件</td><td>在上述打开多个文件的基础上使用</td></tr><tr><td></td><td>:b2</td><td>在显示屏上显示第2个文件</td><td>切换到第2个文件显示</td></tr><tr><td>vim -On file1 file2 …</td><td></td><td>左右分屏显示多个文件</td><td></td></tr><tr><td>vim -on file1 file2 …</td><td></td><td>上下分屏显示多个文件</td><td></td></tr><tr><td></td><td>Ctrl+w s</td><td>上下分割当前打开的所有文件</td><td>在打开多个文件的基础上使用</td></tr><tr><td></td><td>:sp file</td><td>上下分割当前文件和新打开的文件</td><td></td></tr><tr><td></td><td>Ctrl+w v</td><td>左右分割当前打开的所有文件</td><td>在打开多个文件的基础上使用</td></tr><tr><td></td><td>:vsp file</td><td>左右分割当前文件和新打开的文件</td><td></td></tr><tr><td></td><td>Ctrl+w h</td><td>将当前光标移动到左边的分屏</td><td></td></tr><tr><td></td><td>Ctrl+w l</td><td>将当前光标移动到右边的分屏</td><td></td></tr><tr><td></td><td>Ctrl+w H</td><td>将当前光标所在分屏移动到左边</td><td></td></tr><tr><td></td><td>Ctrl+w L</td><td>将当前光标所在分屏移动到右边</td><td></td></tr><tr><td></td><td>Ctrl+w j</td><td>将当前光标移动到下边的分屏</td><td></td></tr><tr><td></td><td>Ctrl+w k</td><td>将当前光标移动到上边的分屏</td><td></td></tr><tr><td></td><td>Ctrl+w J</td><td>将当前光标所在分屏移动到上边</td><td></td></tr><tr><td></td><td>Ctrl+w K</td><td>将当前光标所在分屏移动到下边</td><td></td></tr><tr><td></td><td>:w</td><td>保存当前对文件的修改，但是不退出文件</td><td></td></tr><tr><td></td><td>:w!</td><td>强制保存但是不退出文件</td><td></td></tr><tr><td></td><td>:w file</td><td>保存当前的文件修改到 file 文件当中</td><td></td></tr><tr><td></td><td>:q!</td><td>退出文件，对文件的修改不做保存</td><td></td></tr><tr><td></td><td>:qa!</td><td>退出所有的文件并不做保存</td><td></td></tr><tr><td></td><td>:wq</td><td>退出文件并保存对文件的修改</td><td></td></tr><tr><td></td><td>:x</td><td>退出文件并保存对文件的修改</td><td></td></tr><tr><td></td><td>:e file</td><td>打开另一个文件</td><td></td></tr><tr><td></td><td>:e!</td><td>放弃对文件的所有修改，恢复文件到上次保存的位置</td><td></td></tr><tr><td></td><td>:saveas file</td><td>另存为 file</td><td></td></tr><tr><td></td><td>:bn<code>和</code>:bp</td><td><code>:bn</code> 和 <code>:bp</code> 进行上一个文件或者下一个文件的切换</td><td></td></tr></tbody></table><h3 id="文件编辑"><a href="#文件编辑" class="headerlink" title="文件编辑"></a>文件编辑</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>在光标所在的字符之前插入需要录入的文本</td></tr><tr><td><code>I</code></td><td>在光标所在行的行首插入需要录入的文本</td></tr><tr><td><code>a</code></td><td>在光标所在的字符之后插入需要录入的文本</td></tr><tr><td><code>A</code></td><td>在光标所在行的行尾插入需要录入的文本</td></tr><tr><td><code>o</code></td><td>光标所在行的下一行行首插入需要录入的文本</td></tr><tr><td><code>O</code></td><td>光标所在行的上一行行首插入需要录入的文本</td></tr><tr><td><code>s</code></td><td>删除光标所在处的字符然后插入需要录入的文本</td></tr><tr><td><code>S</code></td><td>删除光标所在行，在当前行的行首开始插入需要录入的文本</td></tr></tbody></table><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>向左移动</td></tr><tr><td>j</td><td>向下移动</td></tr><tr><td>k</td><td>向上移动</td></tr><tr><td>l</td><td>向右移动</td></tr><tr><td><code>0 </code></td><td>移动到行头</td></tr><tr><td><code>^</code></td><td>移动到本行的第一个不是 blank 字符</td></tr><tr><td><code>$</code></td><td>移动到行尾</td></tr><tr><td><code>g_</code></td><td>移动到本行最后一个不是 blank 字符的位置</td></tr><tr><td><code>w</code></td><td>光标移动到下一个单词的开头</td></tr><tr><td><code>e</code></td><td>光标移动到下一个单词的结尾</td></tr><tr><td><code>b</code></td><td>光标移动到上一个单词的开头</td></tr><tr><td><code>fa</code></td><td>移动到本行下一个为 a 的字符处</td></tr><tr><td><code>nG </code></td><td>光标定位到第 n 行的行首</td></tr><tr><td><code>gg </code></td><td>光标定位到第一行的行首</td></tr><tr><td><code>G </code></td><td>光标定位到最后一行的行首</td></tr><tr><td><code>H </code></td><td>光标定位到当前屏幕的第一行行首</td></tr><tr><td><code>M</code></td><td>光标移动到当前屏幕的中间</td></tr><tr><td><code>L</code></td><td>光标移动到当前屏幕的尾部</td></tr><tr><td><code>zt</code></td><td>把当前行移动到当前屏幕的最上方，也就是第一行</td></tr><tr><td><code>zz</code></td><td>把当前行移动到当前屏幕的中间</td></tr><tr><td><code>zb</code></td><td>把当前行移动到当前屏幕的尾部</td></tr><tr><td><code>%</code></td><td>匹配括号移动，包括 ( , { , [ 需要把光标先移动到括号上</td></tr><tr><td><code>*</code></td><td>匹配光标当前所在的单词，移动光标到下一个匹配的单词</td></tr><tr><td><code>#</code></td><td>匹配光标当前所在的单词，移动光标到上一个匹配的单词</td></tr></tbody></table><h3 id="翻页操作"><a href="#翻页操作" class="headerlink" title="翻页操作"></a>翻页操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>ctrl+f</code></td><td>查看下一页内容</td></tr><tr><td><code>ctrl+b</code></td><td>查看上一页内容</td></tr></tbody></table><h3 id="撤销和恢复"><a href="#撤销和恢复" class="headerlink" title="撤销和恢复"></a>撤销和恢复</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>u</code></td><td>撤销刚才的操作</td></tr><tr><td><code>ctrl + r</code></td><td>恢复撤销操作</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2023/09/09/2023-09-09-Linux-1-Vim%E7%BC%96%E8%BE%91%E5%99%A8/vim.png&quot; class=&quot;&quot; title=&quot;Vim&quot;&gt;
&lt;h1 id=&quot;Vim&quot;&gt;&lt;a href=&quot;#Vim&quot; class=&quot;headerlink&quot; title=&quot;Vim&quot;&gt;&lt;/a&gt;&lt;code&gt;Vim&lt;/code&gt;&lt;/h1&gt;&lt;h2 id=&quot;Vim介绍&quot;&gt;&lt;a href=&quot;#Vim介绍&quot; class=&quot;headerlink&quot; title=&quot;Vim介绍&quot;&gt;&lt;/a&gt;&lt;code&gt;Vim&lt;/code&gt;介绍&lt;/h2&gt;&lt;p&gt;VIM 是 Linux 系统上一款文本编辑器，它是操作 Linux 的一款利器。&lt;/p&gt;
&lt;h3 id=&quot;Vim-常用的四个模式：&quot;&gt;&lt;a href=&quot;#Vim-常用的四个模式：&quot; class=&quot;headerlink&quot; title=&quot;Vim 常用的四个模式：&quot;&gt;&lt;/a&gt;&lt;code&gt;Vim&lt;/code&gt; 常用的四个模式：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正常模式 (Normal-mode)&lt;/p&gt;
&lt;p&gt;一般用于浏览文件，也包括一些复制、粘贴、删除等操作。这时击键时，一些组合键就是&lt;code&gt;vim&lt;/code&gt;的功能键，而不会在文本中键入对应的字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;插入模式 (Insert-mode)&lt;/p&gt;
&lt;p&gt;简单的来说，就是编辑文本的模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令模式 (Command-mode)&lt;/p&gt;
&lt;p&gt;在正常模式中，按下&lt;code&gt;:&lt;/code&gt;（冒号）键或者&lt;code&gt;/&lt;/code&gt; （斜杠），会进入命令模式。在命令模式中可以执行一些输入并执行一些 VIM 或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可视模式 (Visual-mode)&lt;/p&gt;
&lt;p&gt;在正常模式按下&lt;code&gt;v, V, &amp;lt;Ctrl&amp;gt;+v&lt;/code&gt;，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。&lt;/p&gt;</summary>
    
    
    
    <category term="技术积累" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>[2023-09-09] Python #1:Pdb调试器</title>
    <link href="http://example.com/2023/09/09/2023-09-09-Python-1-Pdb%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    <id>http://example.com/2023/09/09/2023-09-09-Python-1-Pdb%E8%B0%83%E8%AF%95%E5%99%A8/</id>
    <published>2023-09-09T09:56:09.000Z</published>
    <updated>2023-09-13T12:24:16.976Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/09/09/2023-09-09-Python-1-Pdb%E8%B0%83%E8%AF%95%E5%99%A8/pdb.png" class="" title="Pdb"><h1 id="Pdb介绍"><a href="#Pdb介绍" class="headerlink" title="Pdb介绍"></a>Pdb介绍</h1><p><strong>网址</strong>:<a href="https://docs.python.org/3/library/pdb.html">pdb — The Python Debugger</a></p><p><strong>介绍</strong>:模块pdb为Python程序定义了一个交互式源代码调试器。它支持在源行级别设置（条件）断点和单步执行，检查堆栈帧，列出源代码，以及在任何堆栈帧的上下文中评估任意Python代码。它还支持死后调试，并且可以在程序控制下调用。</p><span id="more"></span><h1 id="Pdb用法"><a href="#Pdb用法" class="headerlink" title="Pdb用法"></a>Pdb用法</h1><ul><li><strong>非侵入式方法</strong>（不用额外修改源代码，在命令行下直接运行就能调试）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pdb filename.py</span><br></pre></td></tr></table></figure><ul><li><strong>侵入式方法</strong>（需要在被调试的代码中添加一行代码然后再正常运行代码）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb;pdb.set_trace()</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">pdb.set_trace()</span><br></pre></td></tr></table></figure><h1 id="Pdb常用命令"><a href="#Pdb常用命令" class="headerlink" title="Pdb常用命令"></a>Pdb常用命令</h1><table><thead><tr><th align="left">完整命令</th><th align="left">命令</th><th align="left">解释</th><th>说明</th></tr></thead><tbody><tr><td align="left">list</td><td align="left">l</td><td align="left">查看当前行的代码段</td><td>查看当前位置前后11行源代码（多次会翻页），当前位置在代码中会用–&gt;这个符号标出来</td></tr><tr><td align="left"></td><td align="left">ll</td><td align="left">查看当前函数或框架的所有源代码</td><td></td></tr><tr><td align="left">break</td><td align="left">b</td><td align="left">设置断点</td><td></td></tr><tr><td align="left"></td><td align="left">b lineno</td><td align="left">在lineno行设置断点</td><td></td></tr><tr><td align="left"></td><td align="left">b filename:lineno</td><td align="left">filename文件名，在filename的lineno行设置断点</td><td></td></tr><tr><td align="left"></td><td align="left">b functionname</td><td align="left">在函数名执行的第一行设置断点</td><td></td></tr><tr><td align="left">tbreak</td><td align="left">\</td><td align="left">临时断点，执行一次后时自动删除（这就是它被称为临时断点的原因）</td><td>参数同break，b</td></tr><tr><td align="left">clear</td><td align="left">cl</td><td align="left">清除所有断点</td><td>1.不带参数用于清除所有断点，会提示确认（包括临时断点）<br/>2.带参数则清除指定文件行或当前文件指定序号的断点</td></tr><tr><td align="left"></td><td align="left">cl filename:lineno</td><td align="left">清除指定文件中的指定行号的断点</td><td>filename: 文件名<br/>lineno: 断点行号</td></tr><tr><td align="left"></td><td align="left">cl bpnumber [bpnumber …]</td><td align="left">清除当前文件中的一个或多个断点</td><td>bpnumber: break point number 断点行号。bpnumber 断点序号（多个以空格分隔）</td></tr><tr><td align="left">print</td><td align="left">p x</td><td align="left">打印变量x的值</td><td></td></tr><tr><td align="left">step</td><td align="left">s</td><td align="left">进入函数（能够进入函数体）（进入 for 循环用 next 而不是用 step）</td><td></td></tr><tr><td align="left">next</td><td align="left">n</td><td align="left">执行下一行（不会进入函数体）</td><td></td></tr><tr><td align="left">return</td><td align="left">r</td><td align="left">执行下一行（在函数中时会直接执行到函数返回处）</td><td></td></tr><tr><td align="left">continue</td><td align="left">c</td><td align="left">持续执行下去，直到遇到一个断点</td><td></td></tr><tr><td align="left">until</td><td align="left">unt lineno</td><td align="left">持续执行直到运行到指定行（或遇到断点）</td><td></td></tr><tr><td align="left">jump</td><td align="left">j lineno</td><td align="left">直接跳转到指定行（注意，被跳过的代码不执行）</td><td></td></tr><tr><td align="left">up</td><td align="left">u</td><td align="left">返回到上个调用点（不是上一行）</td><td></td></tr><tr><td align="left">args</td><td align="left">a</td><td align="left">在函数中时打印函数的参数和参数的值</td><td></td></tr><tr><td align="left">whatis</td><td align="left">whatis expression</td><td align="left">打印表达式的类型，常用来打印变量值</td><td></td></tr><tr><td align="left">where</td><td align="left">w</td><td align="left">打印堆栈信息，最新的帧在最底部。箭头表示当前帧。</td><td></td></tr><tr><td align="left">!</td><td align="left">\</td><td align="left">在pdb中执行语句</td><td></td></tr><tr><td align="left">exit</td><td align="left">q</td><td align="left">中止调试，退出程序</td><td></td></tr><tr><td align="left">help</td><td align="left">\</td><td align="left">帮助</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2023/09/09/2023-09-09-Python-1-Pdb%E8%B0%83%E8%AF%95%E5%99%A8/pdb.png&quot; class=&quot;&quot; title=&quot;Pdb&quot;&gt;

&lt;h1 id=&quot;Pdb介绍&quot;&gt;&lt;a href=&quot;#Pdb介绍&quot; class=&quot;headerlink&quot; title=&quot;Pdb介绍&quot;&gt;&lt;/a&gt;Pdb介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;网址&lt;/strong&gt;:&lt;a href=&quot;https://docs.python.org/3/library/pdb.html&quot;&gt;pdb — The Python Debugger&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;:模块pdb为Python程序定义了一个交互式源代码调试器。它支持在源行级别设置（条件）断点和单步执行，检查堆栈帧，列出源代码，以及在任何堆栈帧的上下文中评估任意Python代码。它还支持死后调试，并且可以在程序控制下调用。&lt;/p&gt;</summary>
    
    
    
    <category term="技术积累" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="Code" scheme="http://example.com/tags/Code/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
</feed>
